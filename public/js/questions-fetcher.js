let questionsContainer=document.getElementById("questions-container"),loader=document.getElementById("loader"),page=1,observer=null;function noMoreQuestions(){let e=document.createElement("p");e.textContent="No more questions to show",e.classList.add("text-center","text-secondary"),questionsContainer.appendChild(e),loader.remove()}async function createQuestionPreview(e,t){return new Promise(async(t,n)=>{try{let o=await fetch("/questions/preview/"+e.id,{method:"GET",headers:{"X-Requested-With":"XMLHttpRequest"}});if(!o.ok)throw Error("Failed to fetch question preview");let r=await o.text();loader.insertAdjacentHTML("beforebegin",r);let s=document.createElement("hr");questionsContainer.insertBefore(s,loader),t()}catch(a){console.log("Failed to fetch question preview: ",a),n(a)}})}async function fetchQuestions(){let e=new URL(window.location.href);e.pathname="/api"+e.pathname,e.searchParams.append("page",page++);let t=await fetch(e),n=await t.json();return n}async function insertQuestions(){observer.unobserve(loader);let e=await fetchQuestions(),t=e.questions.data;if(0===t.length){noMoreQuestions();return}let n=t.map(t=>createQuestionPreview(t,e.authenticated));await Promise.all(n),observer.observe(loader),t.length<10&&noMoreQuestions()}function handleIntersection(e){e.forEach(e=>{e.isIntersecting&&insertQuestions()})}function questionScrollObserver(){(observer=new IntersectionObserver(handleIntersection)).observe(loader)}export default questionScrollObserver;